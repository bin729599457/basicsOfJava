
## java中的参数传递——值传递、引用传递

- 1.对象就是传引用
- 2.原始类型就是传值
- 3.String类型因为没有提供自身修改的函数，每次操作都是新生成一个String对象，所以要特殊对待。可以认为是传值。

## 字符流和字节流的区别

    字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节， 操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是 音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点. 
    所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列. 
    字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以

## 抽象类和接口的区别

    如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
    如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
    如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。



### |参数|抽象类|接口|

    |默认的方法实现|它可以有默认的方法实现|接口完全是抽象的，它根本不存在方法的实现|
    |构造器|抽象类可以有构造器|接口不能有构造器|
    |与正常Java类的区别|除了不能实例化抽象类，它和普通Java类无任何区别|接口属于完全不同的类型|
    |访问修饰符|public、protected、default均可|默认public,不可使用其它修饰符|
    |速度|比接口速度快|稍微慢，因为需要时间去寻找在类中实现的方法|
    |添加新方法|如果往抽象类添加新方法，可以给它提供默认的实现。因此不需要改变现在的代码|往接口添加方法，那么必须改变实现该接口的所有类|


## Iterator和 for each的区别： 

    1.for each 不能删除集合元素 
    2.Iterator 只能使用自身的remove()方法来删除元素，不能用集合的删除操作 
    3.ArrayList里，for循环较快，LinkedList里，使用iterator较快


## 位运算符

    假设a = 60，b = 13;它们的二进制格式表示将如下：

    A = 0011 1100
    B = 0000 1101

-----------------

    A&b = 0000 1100
    A | B = 0011 1101
    A ^ B = 0011 0001
    ~A= 1100 0011

## final、finally、finalize的区别
- 1、final 修饰符（关键字）
        final用于控制成员、方法或者是一个类是否可以被重写或者继承等功能，如果要学好java，那么这个关键字很重要，必须掌握。如果类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。将变量或者方法声明为final，可以保证他们在使用中不被改变。其初始化可以在两个地方：一是其定义处，也就是说，在final变量定义时直接给其赋值；二是构造函数中。这2个地方只能选其一，要么在定义处直接给其赋值，要么在构造函数中给值，并且在以后的引用中，只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写。

- 2、finally(用于异常处理)
        一般是用于异常处理中，提供finally块来执行任何的清楚操作，try{} catch(){} finally{}。finally关键字是对java异常处理模型的最佳补充。finally结构使代码总会执行，不关有无异常发生。使得finally可以维护对象的内部状态，并可以清理非内存资源。finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally快中的操作。一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。

- 3、finalize（用于垃圾回收）
         finalize这个是方法名。在java中，允许使用finalize()方法在垃圾收集器将对象从内存中清理出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用是对这个对象调用的。它是Object类中定义的，因此，所有的类都继承了它。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

## char 型变量中能不能存贮一个中文汉字?为什么?
    char 型变量是用来存储 Unicode 编码的字符的， unicode 编码字符集中包含了汉字，所以，char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。 
补充说明： unicode 编码占用两个字节，所以， char 类型的变量也是占用两个字节。


## 一、重写toString方法返回对象信息

```java    
@Override
    public String toString() {
	return “the property what you want”;
    }
```
    (toString()是定义在类Object的1个非静态方法.这意味这个方法必须需要1个已实例化对象才能调用. 也就是为什么我们定义1个整形变量 int x时, 不能利用x.toString()方法把x转化为字符串.因为x只是1个基本变量, 而不是1个对象.)

## Java数组与内存控制

    JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)
    堆区:1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身栈区:1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。方法区:1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。

### 一、Java数组初始化

    Java数组是静态的，即当数组被初始化之后，该数组的长度是不可变的。Java数组使用之前必须先对数组对象进行初始化，所谓初始化，就是为数组的所有元素分配内存空间，并为每个数组元素指定初始值。
    Java基本类型数组的两种初始化方式
	•	静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。
	•	动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。

    不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。
    Java的数组是静态的，一旦数组初始化完成，数组元素的内存空间分配即结束，程序只能改变数组元素的值，而无法改变数组的长度。Java的数组变量是一种引用类型的变量，数组变量并不是数组本身，它只是指向堆内存中的数组对象。因此，可以改变一个数组变量所引用的数组，这样可以造成数组长度可变的假象。
### 二：Java数组内存存放

    对于基本类型数组而言，数组元素的值直接存储在对应的数组元素中，因此基本类型数组的初始化比较简单：程序直接先为数组分配内存空间，再将数组元素的值存入对应内存里。
    所有局部变量都是存放在栈内存里保存的，不管其是基本类型的变量，还是引用类型的变量，都是存储在各自的方法栈区中；但引用类型变量所引用的对象（数组、普通Java对象）则总是存储在堆内存中。
    对于很多Java程序员而言，他们最容易混淆的是：引用类型变量何时只是栈内存中的变量本身，何时又变为引用实际的Java对象。其实规则很简单：引用变量本质上只是一个指针，只要程序通过引用变量访问属性，或者通过调用引用变量来调用方法，该引用变量将会由它所引用的对象代替。
### 三：使用数组

    当数组引用变量指向一个有效的数组对象之后，程序就可以通过该数组引用变量来访问数组对象。Java语言不允许直接访问堆内存中的数据，因此无法直接访问堆内存中的数组对象，程序将通过数组引用变量来访问数组。
